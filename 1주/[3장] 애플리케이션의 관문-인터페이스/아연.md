## HTTP 요청/응답 흐름에 따른 NestJS 대응

![클라이언트가 서버 요청 시 흐름과 NestJS 대응 코드](/assets/ayeon/3_IMG_6265.jpg)

1. 가드 ➝ 인터셉터 ➝ 파이프 ➝ Controller ➝ Service ➝ Repository

2. Controller 필수

- 클라이언트에서 온 요청을 코드에 전달하기 위함
- 컨트롤러 클래스는 모듈에 포함되어 있어야 함

3. 최소 하나의 모듈과 하나의 컨트롤러가 필요함
4. 네이밍 규칙

- 파일명: <모듈명>.<컴포넌트명>.ts
- 클래스명: <모듈명><컴포넌트명> CamelCase

## 의존 관계

1. 제어의 역전 원칙 이용

- 객체를 직접 생성하지 않고 생성자나 필드 선언에 데코레이터 추가해 의존성 객체 주입
- 개발자가 객체를 생성하지 않고, @Injectable 데코레이터를 사용해 선언만 함
- 프레임워크가 생성한 컨테이너가 의존성을 관리함

2. 의존 관계

- 컨트롤러는 서비스 사용하고, 서비스는 리포지토리 사용함
- 프로바이더 : @Injectable 사용해 다른 클래스에 주입해 사용 가능한 클래스

## 의존성 주입

1. 리포지토리와 서비스에 @Injectable 데코레이터 추가
2. 컨트롤러 생성자와 서비스 생성자에서 의존성 객체 생성하지 않고 선언만 함
3. AppModule의 @Module 데코레이터에 프로바이더 설정 추가

## Controller

1. 들어오는 요청(request)를 받고 처리된 결과를 응답(response)으로 돌려주는 인터페이스

- 유저가 보낸 HTTP 요청을 어떤 코드로 처리할지 정하는 역할

2. @Controller 데코레이터

- 클래스에 선언하여 해당 클래스가 컨트롤러 역할하게 함

3. 엔드포인트 라우팅(routing) 메커니즘

- 각 컨트롤러가 받을 수 있는 요청 분류
- HTTP 요청 객체 + 데코레이터 활용 ➝ 적절한 컨트롤러 실행됨

4. 라우트 경로 관리

- HTTP 메서드: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head() 데코레이터의 인자 활용

  **HTTP 메서드 데코레이터의 인자로 라우팅 경로 지정**

  - 루트 경로 : @Get() : http://localhost:3000
  - /hello 경로 : @Get('/hello') : http://localhost:3000/hello

  **컨트롤러 데코레이터의 인자로 라우팅 경로의 prefix 지정**

  - prefix: 컨트롤러가 맡은 리소스의 이름
  - @Controller('app') : http://localhost:3000/app
  - @Controller('app'), @Get('/hello') : http://localhost:3000/app/hello

5. 와일드카드

- `*` 외에 `?, +, ()` 문자 역시 정규 표현식에서의 와일드 카드와 동일하게 동작
- `-`과 `.`은 문자열로 취급
- 예시 1
  ```
  @Get('abcd/*')
  findAll() {
      return 'This route uses a wildcard';
  }
  ```
  - GET /abcd/ → 매칭
  - GET /abcd/123 → 매칭
  - GET /abcd/abc → 매칭
  - GET /abcd/xyz/456 → 매칭
- 예시 2
  ```
  @Get('he*lo')
  getHello(): string {
      return this.appService.getHello();
  }
  ```
  - GET /helo → 매칭
  - GET /hello → 매칭
  - GET /he\_\_lo → 매칭
